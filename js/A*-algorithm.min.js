SquareMap.prototype.executeAStarAlgorithm=function(f,d){var c=new Set();var b,a,e;startNode=map.getNode(f);c.add(startNode.getCoordinate());startNode.setGCost(0);startNode.setFCost(0+heuristicCost(f,d));while(c.size()>0){var b=getOptimum(openSet);if(!b){alert("no path");return false}if(b.getCoordinate().equals(d)){reconstructPath(b);return true}openNodes.remove(b.getCoordinate());b.setClosed();neighbourNodesCoordinates=this.getNeighboursCoordinates(b);neighbourNodesCoordinates.each(function(g){neighbour=map.getNode(g);if(!neighbour.isClosed()){e=b.getGCost()+heuristicCost(b.getCoordinate(),neighbour.getCoordinate());if((e<neighbour.getGCost())||(!openNodes.contains(neighbour))){neighbour.setPredecessor(b);neighbour.setGCost(e);neighbour.setFCost(neighbour.getGCost()+heuristicCost(neighbour.getCoordinate(),d));if(!openNodes.contains(neighbour)){openNodes.add(neighbour);neighbour.setOpen()}}}})}return false};function heuristicCost(e,d){var c=Math.pow((e.getRow()-d.getRow()),2);var a=Math.pow((e.getColumn()-d.getColumn()),2);var b=Math.sqrt(c+a);return b}function getOptimum(b){var a;var c;if(b.size()==0){alert("There is no path!");return null}else{b.each(function(e){var d=map.getNode(e);if((!c)||(d.getFCost()<a)){a=d.getFCost();c=d}})}b.remove(c.getCoordinate());return c}SquareMap.prototype.executeAStarAlgorithmRecursive=function(g,e,a){var c=new Set();var b,f;var d=true;startNode=map.getNode(g);c.add(startNode.getCoordinate());startNode.setGCost(0);startNode.setFCost(0+heuristicCost(g,e));setTimeout(function(){map.executeAStarStep(d,c,e,a)},a)};SquareMap.prototype.executeAStarStep=function(c,a,f,b){var e;var d=getOptimum(a);if(!d){c=false;return c}if(d.getCoordinate().equals(f)){reconstructPath(d);setTimeout(function(){showStatistics()},b);return true}a.remove(d.getCoordinate());d.setClosed();e=this.getNeighboursCoordinates(d);e.each(function(g){neighbour=map.getNode(g);if(!neighbour.isClosed()){tentativeCost=d.getGCost()+heuristicCost(d.getCoordinate(),neighbour.getCoordinate());if((tentativeCost<neighbour.getGCost())||(!a.contains(neighbour.getCoordinate()))){neighbour.setPredecessor(d);neighbour.setGCost(tentativeCost);neighbour.setFCost(neighbour.getGCost()+heuristicCost(neighbour.getCoordinate(),f));if(!a.contains(neighbour.getCoordinate())){a.add(neighbour.getCoordinate());neighbour.setOpen()}}}});setTimeout(function(){map.executeAStarStep(c,a,f,b)},b)};